//@author: a0113555l



	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\addTaskTest\unittest1.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace Logic_Test {
	TEST_CLASS(Logic_Test) {
public:

	TEST_METHOD(executeCommand_add) {
		Logic testLogic;

		Task* test = new Task("Andy's bday", "14/4/2015", "13:00", "14/4/2015", "14:00", "", "", "!h", "");
		Task* test1 = new Task("Andy's bday1", "14/4/2015", "13:00", "14/4/2015", "14:00", "", "", "!h", "");
		Task* test1_copy = new Task("Andy's bday1", "14/4/2015", "13:00", "14/4/2015", "14:00", "", "", "!h", "");

		paraList testParaList;
		paraList testParaList1;
		paraList testParaList1_copy;

		testParaList.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *test);
		testParaList1.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *test1);
		testParaList1_copy.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *test1_copy);

		string feedBack = testLogic.executeCommand(testParaList);
		string feedBack1 = testLogic.executeCommand(testParaList1);
		string feedBack1_copy = testLogic.executeCommand(testParaList1_copy);

		string actualOutputString = feedBack;
		string actualOutputString1 = feedBack1;
		string expectedOutputString = "Task Added Successfully! :>";

		Assert::AreEqual(expectedOutputString, actualOutputString);
		Assert::AreEqual(expectedOutputString, actualOutputString1);

	}

	TEST_METHOD(executeCommand_delete) {

		Logic testLogic;

		Task* test = new Task("Andy's bday", "10/4/2015", "13:00", "10/4/2015", "14:00", "11/4/2015", "00:00", "high", "Incompleted");
		Task* test1 = new Task("Andy's bday1", "10/4/2015", "13:00", "10/4/2015", "14:00", "11/4/2015", "00:00", "high", "Incompleted");

		paraList testParaList;
		paraList testParaList1;
		paraList testParaList2;

		testParaList.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *test);
		testParaList1.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *test1);
		testParaList2.setparaList("delete", 1, 1, 1, "KEYWORD", "INPUT", *test1);

		testLogic.setTaskList();
		string feedBack1 = testLogic.executeCommand(testParaList);
		testLogic.setTaskList();
		string feedBack2 = testLogic.executeCommand(testParaList1);
		testLogic.setTaskList();
		string feedBack = testLogic.executeCommand(testParaList2);

		string expectedOutputString = feedBack;
		string actualOutputString = "Task Deleted Successfully!";

		Assert::AreEqual(expectedOutputString, actualOutputString);
	}
	};
}

	// End of segment: C:\Users\User\Desktop\TaskSotong\main\addTaskTest\unittest1.cpp





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\Common_Testing\Common_Testing.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace Task_Testing
{
	TEST_CLASS(Task_Testing)
	{
	public:
		TEST_METHOD(getTaskName_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actualName;
			actualName = test->getTaskName();

			string expectedName = "Name";

			Assert::AreEqual(expectedName, actualName);

		}

		TEST_METHOD(getTaskStartDate_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskStartDate();

			string expected = "StartDate";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(getTaskStartTime_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskStartTime();

			string expected = "StartTime";

			Assert::AreEqual(expected, actual);


		}

		TEST_METHOD(getTaskEndDate_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskEndDate();

			string expected = "EndDate";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(getTaskEndTime_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskEndTime();

			string expected = "EndTime";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(getTaskDeadlineDate_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskDeadlineDate();

			string expected = "DeadlineDate";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(getTaskDeadlineTime_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskDeadlineTime();

			string expected = "DeadlineTime";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(getTaskPriority_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			actual = test->getTaskPriority();

			string expected = "Priority";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(getTaskStatus_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incomplete");
			string actual;
			actual = test->getTaskStatus();

			string expected = "Incomplete";

			Assert::AreEqual(expected, actual);

		}


		TEST_METHOD(changeTaskName_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskName("Name1");
			actual = test->getTaskName();

			string expected = "Name1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskStartDate_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskStartDate("StartDate1");
			actual = test->getTaskStartDate();

			string expected = "StartDate1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskStartTime_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskStartTime("StartTime1");
			actual = test->getTaskStartTime();

			string expected = "StartTime1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskEndDate_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskEndDate("EndDate1");
			actual = test->getTaskEndDate();

			string expected = "EndDate1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskEndTime_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskEndTime("EndTime1");
			actual = test->getTaskEndTime();

			string expected = "EndTime1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskDeadlineDate_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskDeadlineDate("DeadlineDate1");
			actual = test->getTaskDeadlineDate();

			string expected = "DeadlineDate1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskDeadlineTime_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskDeadlineTime("DeadlineTime1");
			actual = test->getTaskDeadlineTime();

			string expected = "DeadlineTime1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskPriority_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			string actual;
			test->changeTaskPriority("Priority1");
			actual = test->getTaskPriority();

			string expected = "Priority1";

			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(changeTaskStatus_test)
		{
			Task* test = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incomplete");
			string actual;
			test->changeTaskStatus("mark");
			actual = test->getTaskStatus();

			string expected = "Completed";

			Assert::AreEqual(expected, actual);

			Task* test2 = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
			test2->changeTaskStatus("abcd");
			string actual2 = test2->getTaskStatus();
			string expected2 = "Incomplete";

			Assert::AreEqual(expected2, actual2);


		}
	};
}
	// End of segment: C:\Users\User\Desktop\TaskSotong\main\Common_Testing\Common_Testing.cpp





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\Logic\Logic.cpp
	 */

#include "Logic.h"
#include "Shlwapi.h"
#include <windows.h>
#include <direct.h>
#include <stack>
#include <stdio.h>

using namespace std;

string Logic::SAVING_LOCATON_HISTORY = "taskSotong_saving_Location_history.txt";

string Logic::ERROR_INVALID_USERINPUT = "Invalid User Input. Please Enter Again! :<";
string Logic::ERROR_EXISTING_TASK = "That Task Has Already Existed~! ";
string Logic::ERROR_TASK_UPDATED_UNSUCCESSFULLY = "Failed To Update The Task!";
string Logic::ERROR_TASK_DELETED_UNSUCCESSFULLY = "Failed To Delete The Task!";
string Logic::ERROR_TASK_MARKED_UNSUCCESSFULLY = "Nah.. Index Out Of Range! Cannot Mark!";
string Logic::ERROR_TASK_UNMARKED_UNSUCCESSFULLY = "Nah.. Index Out Of Range! Cannot Unmark!";
string Logic::ERROR_EMPTY_LIST = "Task List Is Empty!";
string Logic::ERROR_TASK_INSUFFICIENT_PARAMETERS = "Insufficient Parameters Entered!";
string Logic::ERROR_NO_INDEX = "No Index! :<";
string Logic::ERROR_INDEX_OUT_OF_RANGE = "Index Out Of Range!";
string Logic::ERROR_NO_COMPONENT = "No Component!";
string Logic::ERROR_COMPONENT_INVALID = "Component Invalid!";
string Logic::ERROR_NO_CONTENT = "No Content!";
string Logic::ERROR_INVALID_CONTENT = "Content Invalid!";
string Logic::ERROR_INVALID_YEAR = "Year Entered Is Invalid!";
string Logic::ERROR_INVALID_MONTH = "Month Entered Is Invalid!";
string Logic::ERROR_INVALID_DAY = "Day Entered Is Invalid";
string Logic::ERROR_INVALID_HOUR = "Hour Entered Is Invalid";
string Logic::ERROR_INVALID_MINUTE = "Minute Entered Is Invalid";
string Logic::ERROR_START_TIME_AFTER_END_TIME = "Start Time After End Time!";
string Logic::ERROR_START_DATE_AFTER_END_DATE = "Start Date After End Date :<";

string Logic::FEEDBACK_TASK_ADDED_SUCCESSFULLY = "Task Added Successfully! :>";
string Logic::FEEDBACK_DISPLAY_ALL_TASKS = "All Tasks Are Displayed!";
string Logic::FEEDBACK_TASK_UPDATED_SUCCESSFULLY = "Task Updated Successfully!";
string Logic::FEEDBACK_TASK_DELETED_SUCCESSFULLY = "Task Deleted Successfully!";
string Logic::FEEDBACK_SAVING_FILE_DIRECTORY_CHANGED = "Saving directory changed! :D";
string Logic::FEEDBACK_TASK_MARKED_SUCCESSFULLY = "Task Marked Completed! ";
string Logic::FEEDBACK_TASK_UNMARKED_SUCCESSFULLY = "Unmarked The Task!";
string Logic::FEEDBACK_CLEAR_ALL_TASKS = "All Tasks Cleared!";
string Logic::FEEDBACK_UNDO_PREVIOUS_TASK = "Undo Completed! :D";
string Logic::FEEDBACK_SEARCH_TASK_BY_KEYWORD = "Search Result Displayed! :D";
string Logic::FEEDBACK_SORT_TASK_BY_KEYWORD = "Tasks Sorted Accordingly!";
string Logic::FEEDBACK_VIEW_ALL_SUCCESSFULLY = "Viewing All Tasks!";

//this function checks if the start time or end time or deadline time is of the correct 23:59 format
string Logic::checkTimeValidity(string timeInput) {

	assert(timeInput != "");

	string tempFeedback = "Pass Time Test";

	string tempMinute = timeInput.substr(timeInput.find_first_of(":") + 1, timeInput.length());
	string tempHour = timeInput.substr(0, timeInput.find_first_of(":"));

	int minute = atoi(tempMinute.c_str());
	int hour = atoi(tempHour.c_str());

	if ((hour < 0) || (hour>23)) {
		tempFeedback = ERROR_INVALID_HOUR;
	} else if (minute > 59) {
		tempFeedback = ERROR_INVALID_MINUTE;
	}

	return tempFeedback;
}

//this function checks if the start date or end date or deadline date is of the correct  day/month/year format
string Logic::checkDateValidity(string dateInput) {

	assert(dateInput != "");

	string tempFeedback = "Pass Date Test";

	string tempYear = dateInput.substr(dateInput.length() - 4, dateInput.length());
	string temp = dateInput.substr(0, dateInput.length() - 5);
	string tempMonth = temp.substr(temp.find_last_of("/") + 1, temp.length());
	string tempDay = temp.substr(0, temp.find_first_of("/"));

	int year = atoi(tempYear.c_str());
	int month = atoi(tempMonth.c_str());
	int day = atoi(tempDay.c_str());

	if (year < 2015) {
		tempFeedback = ERROR_INVALID_YEAR;
	} else if ((month < 1) || (month>12)) {
		tempFeedback = ERROR_INVALID_MONTH;
	} else if (day < 1) {
		tempFeedback = ERROR_INVALID_DAY;
	} else if ((month == 1) || (month == 3) || (month == 5) || (month == 7) || (month == 8) || (month == 10) || (month == 12)) {
		if (day>31) {
			tempFeedback = ERROR_INVALID_DAY;
		}
	} else if (month == 2) {
		if (day > 28) {
			tempFeedback = ERROR_INVALID_DAY;;
		}
	} else if (day > 30) {
		tempFeedback = ERROR_INVALID_DAY;
	}

	return tempFeedback;

}

//within a certain task, check if the start date and end date make sense
//e.g. It is impossible to have a start date that is after the end date
string Logic::checkTaskDatenTimeValidity(Task taskInput) {

	string tempFeedback;
	tempFeedback = "Pass Test";

	string taskStartDate = taskInput.getTaskStartDate();
	string taskStartTime = taskInput.getTaskStartTime();
	string taskEndDate = taskInput.getTaskEndDate();
	string taskEndTime = taskInput.getTaskEndTime();
	string taskDeadlineDate = taskInput.getTaskDeadlineDate();
	string taskDeadlineTime = taskInput.getTaskDeadlineTime();

	vector<string> dateVector;
	dateVector.push_back(taskStartDate);
	dateVector.push_back(taskEndDate);
	dateVector.push_back(taskDeadlineDate);

	vector<string> timeVector;
	timeVector.push_back(taskStartTime);
	timeVector.push_back(taskEndTime);
	timeVector.push_back(taskDeadlineTime);

	vector<string> componentVector;
	componentVector.push_back("Start Date: ");
	componentVector.push_back("End Date: ");
	componentVector.push_back("Deadline Date: ");
	componentVector.push_back("Start Time: ");
	componentVector.push_back("End Time: ");
	componentVector.push_back("Deadline Time: ");

	string feedbackMsg_Date = "";
	for (int i = 0; i < dateVector.size(); i++) {

		if (dateVector[i] == "") {

		} else {
			feedbackMsg_Date = checkDateValidity(dateVector[i]);
			if (feedbackMsg_Date != "Pass Date Test") {
				tempFeedback = componentVector[i] + feedbackMsg_Date;
				break;
			}
		}
	}

	if (tempFeedback == "Pass Test") {

		string feedbackMsg_Time = "";
		for (int j = 0; j < timeVector.size(); j++) {

			if (timeVector[j] == "") {
			} else {
				feedbackMsg_Time = checkTimeValidity(timeVector[j]);
				if (feedbackMsg_Time != "Pass Time Test") {
					tempFeedback = componentVector[j % 3] + feedbackMsg_Time;
					break;
				} else {
				}
			}
		}
	}

	return tempFeedback;

}

string Logic::convertYearToCorrectForm(string input) {

	string output;
	if (input == "") {
		output = "";
	} else {
		string tempYear = input.substr(input.length() - 4, input.length());
		string temp = input.substr(0, input.length() - 5);
		string tempMonth = temp.substr(temp.find_last_of("/") + 1, temp.length());
		string tempDay = temp.substr(0, temp.find_first_of("/"));

		output = tempYear + tempMonth + tempDay;
	}

	return output;

}

//this function converts the input string to a standard form of 23:59
string Logic::convertTimeToCorrectForm(string input) {

	string tempMinute = input.substr(input.find_first_of(":") + 1, input.length());
	string tempHour = input.substr(0, input.find_first_of(":"));
	string output = tempHour + tempMinute;

	return output;

}

string Logic::compareTaskDateandTime(Task taskInput) {

	string tempStartDate = taskInput.getTaskStartDate();
	string tempStartTime = taskInput.getTaskStartTime();
	string tempEndDate = taskInput.getTaskEndDate();
	string tempEndTime = taskInput.getTaskEndTime();

	string startDate = convertYearToCorrectForm(tempStartDate);
	string startTime = convertTimeToCorrectForm(tempStartTime);
	string endDate = convertYearToCorrectForm(tempEndDate);
	string endTime = convertTimeToCorrectForm(tempEndTime);

	string tempFeedback = "";
	if (startDate == "" || endDate == "") {

	} else if (startDate == endDate) {
		if (startTime > endTime) {
			tempFeedback = ERROR_START_TIME_AFTER_END_TIME;
		} else {
		}
	} else if (startDate > endDate) {
		tempFeedback = ERROR_START_DATE_AFTER_END_DATE;
	} else {
	}
	return tempFeedback;
}

void Logic::setTaskList() {

	_storageTaskListCopy = _DataBase.returnTaskList();
}

vector<Task> Logic::getTaskList() {

	return _storageTaskListCopy;
}

void Logic::setCompletedTaskList() {

	_storageTaskListCopy = _DataBase.returnCompletedTaskList();
}

vector<Task> Logic::getCompletedTaskList() {

	return _storageTaskListCopy;
}

void Logic::setIncompleteTaskList() {

	_storageTaskListCopy = _DataBase.returnIncompleteTaskList();
}

vector<Task> Logic::getIncompleteTaskList() {

	return _storageTaskListCopy;
}

void Logic::initialiseSetUp() {

	initialiseFileLocationFile();
	bool areInTheSameLocation = checkIfFileIsAtExeLocation();
	string filename;
	if (areInTheSameLocation == false) {

		string lastFileLocation = getLastFileLocation();
		setFileName(lastFileLocation);
	} else {

		string exePath = getExePath() + "\\taskSotong.txt";
		setFileName(exePath);

	}
	filename = getFileName();
	callInitialise(filename);

}

void Logic::initialiseFileLocationFile() {

	ifstream readFile(SAVING_LOCATON_HISTORY);
	string tempStorage;

	while (getline(readFile, tempStorage)) {
		_fileLocation.push_back(tempStorage);
	}

	readFile.close();

	return;
}

void Logic::writeFileLocation(vector<string> fileLocation) {

	ofstream writeFile(SAVING_LOCATON_HISTORY);

	for (unsigned int i = 0; i < fileLocation.size(); i++) {
		writeFile << fileLocation[i] << endl;
	}

	return;
}

bool Logic::checkIfFileIsAtExeLocation() {

	int lastIndex = _fileLocation.size();

	try{
		if (lastIndex < 0)
		{
			throw;

		}


	}
	catch (...) {

		cout << "Exception case: Last index is not a positive integer";

	}

	if (lastIndex == 0) {
		return true;
	} else {

		string lastLocation = _fileLocation[lastIndex - 1];
		string exeLocation = getExePath();

		if (lastLocation == exeLocation) {
			return true;
		} else {
			return false;
		}
	}
}

string Logic::getLastFileLocation() {

	int lastIndex = _fileLocation.size();

	return _fileLocation[lastIndex - 1];
}

void Logic::updatefileLocation(string userDirectory) {

	assert(userDirectory != "");

	_fileLocation.push_back(userDirectory);

	return;
}

//this function only gets the directory of the .exe file, not where the .txt file is. 
string Logic::getExePath() {

	char buffer[MAX_PATH];
	GetModuleFileName(NULL, buffer, MAX_PATH);
	string::size_type pos = string(buffer).find_last_of("\\/");

	return string(buffer).substr(0, pos);
}

void Logic::createNewDirectory(string userFileDirectory) {

	assert(userFileDirectory != "");

	int index = userFileDirectory.find_last_of('\\');
	int index2 = userFileDirectory.find_first_of('\\');
	string inputDirectory = userFileDirectory.substr(0, index);

	stack<string> directoryParts;
	int firstIndex = inputDirectory.find_last_of('\\');
	
	try{

		if (firstIndex < 0)
		{

			throw;
		}

	}
	catch (...)
	{
		cout << "Exceptional case:firstIndex is not positive";

	}
	
	
	while (firstIndex != -1) {
    
		firstIndex = inputDirectory.find_last_of('\\');
		string temp = inputDirectory.substr(firstIndex, inputDirectory.size() - 1);

		if (temp == "\\") {
		} else {
			directoryParts.push(temp);
		}

		inputDirectory = inputDirectory.substr(0, firstIndex);

		firstIndex = inputDirectory.find_last_of('\\');
	}

	directoryParts.push(inputDirectory);
	string directory = directoryParts.top();
	directoryParts.pop();

	while (!directoryParts.empty()) {

		directory = directory + directoryParts.top();
		_mkdir(directory.c_str());
		directoryParts.pop();
	}

	return;
}

//new location should be saved in this format: "C:\ts\ts1\gt.txt";
void Logic::changeFileDirectory(string userFileDirectory) {

	assert(userFileDirectory != "");

	createNewDirectory(userFileDirectory);
	setFileName(userFileDirectory);

	return;
}


void Logic::setFileName(string updatedFileName) {

	assert(updatedFileName != "");

	_filename = updatedFileName;

	return;
}

string Logic::getFileName() {

	return _filename;
}

paraList* Logic::getParaList(string userInput) {

	return _ParserComponent.parseCommand(userInput);
}


string Logic::getLowerCaseCommand(paraList parameterList) {
	string command = parameterList.getCommand();
	transform(command.begin(), command.end(), command.begin(), tolower);

	return command;

}

Task Logic::getTask(paraList parameterList) {

	return parameterList.getTask();
}

void Logic::callInitialise(string outputFile) {

	_DataBase.initialiseTextFile(outputFile);

	return;
}

bool Logic::ExistingTask(Task task) {

	setTaskList();
	bool existing = false;
	string name = task.getTaskName();
	string startDate = task.getTaskStartDate();
	string startTime = task.getTaskStartTime();
	string endDate = task.getTaskEndDate();
	string endTime = task.getTaskEndTime();
	string deadlineDate = task.getTaskDeadlineDate();
	string deadlineTime = task.getTaskDeadlineTime();
	string priority = task.getTaskPriority();
	string status = task.getTaskStatus();

	if (_storageTaskListCopy.size() == 0) {

	} else {

		Task checkItem;
		for (int i = 0; i < _storageTaskListCopy.size(); i++) {
			checkItem = _storageTaskListCopy[i];
			if (name == checkItem.getTaskName()) {
				if (startDate == checkItem.getTaskStartDate()) {
					if (startTime == checkItem.getTaskStartTime()) {
						if (endDate == checkItem.getTaskEndDate()) {
							if (endTime == checkItem.getTaskEndDate()) {
								if (deadlineDate == checkItem.getTaskDeadlineDate()) {
									if (deadlineTime == checkItem.getTaskDeadlineTime()) {
										if (priority == checkItem.getTaskPriority()) {
											if (status == checkItem.getTaskStatus()) {
												existing = true;
											}
										}

									}
								}
							}
						}
					}
				}
			}
		}

	}

	return existing;
}

string Logic::getFeedbackMsg() {

	return _feedbackMessage;
}

string Logic::executeCommand(paraList Input) {

	_Logic_LogFile.writeToLogFile("******************LOGIC_EXECUTECOMMAND_START*******************");

	string command = getLowerCaseCommand(Input);
	if (command == "exit") {
		exit(0);

	} else if (command == "add") {
		_Logic_LogFile.writeToLogFile(command);
		Task oneTask = Input.getTask();
		if (ExistingTask(oneTask) == true) {
			_feedbackMessage = ERROR_EXISTING_TASK;
		} else {

			string tempFeedback;
			tempFeedback = checkTaskDatenTimeValidity(oneTask);

			if (tempFeedback != "Pass Test") {
				_feedbackMessage = tempFeedback;
			} else {

				tempFeedback = compareTaskDateandTime(oneTask);

				if (tempFeedback != "") {
					_feedbackMessage = tempFeedback;
				} else {
					_DataBase.addTask(oneTask);
					_DataBase.updateTextFile(_filename);
					setTaskList();
					_feedbackMessage = FEEDBACK_TASK_ADDED_SUCCESSFULLY;
				}
			}
		}

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "update") {
		_Logic_LogFile.writeToLogFile(command);
		int updateInteger = Input.getUpdateInteger();
		string parameterToBeUpdated = Input.getKeyword();
		string detailToBeUpdated = Input.getInput();

		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else if (updateInteger < 0) {
			_feedbackMessage = ERROR_NO_INDEX;
		} else if (updateInteger > _storageTaskListCopy.size()) {
			_feedbackMessage = ERROR_INDEX_OUT_OF_RANGE;
		} else if (parameterToBeUpdated == "name") {
			if (detailToBeUpdated == "") {
				_feedbackMessage = ERROR_NO_CONTENT;
			} else {

				_DataBase.updateTask(_filename, updateInteger, parameterToBeUpdated, detailToBeUpdated);
				_DataBase.updateTextFile(_filename);
				setTaskList();
				_feedbackMessage = FEEDBACK_TASK_UPDATED_SUCCESSFULLY;

			}

		} else if ((parameterToBeUpdated == "start-date") || (parameterToBeUpdated == "end-date") || (parameterToBeUpdated == "deadline-date")) {
			if (detailToBeUpdated == "") {
				_feedbackMessage = ERROR_NO_CONTENT;
			} else {

				_feedbackMessage = checkDateValidity(detailToBeUpdated);

				if (_feedbackMessage == "Pass Date Test") {

					string copyofParameterToBeUpdated = parameterToBeUpdated;
					string copyofOriginalDetail;

					if (copyofParameterToBeUpdated == "start-date") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskStartDate();
					} else if (copyofParameterToBeUpdated == "start-time") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskStartTime();
					} else if (copyofParameterToBeUpdated == "end-date") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskEndDate();
					} else if (copyofParameterToBeUpdated == "end-time") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskEndTime();
					}

					_DataBase.updateTask(_filename, updateInteger, parameterToBeUpdated, detailToBeUpdated);
					_DataBase.updateTextFile(_filename);
					setTaskList();

					_feedbackMessage = compareTaskDateandTime(_storageTaskListCopy[updateInteger - 1]);
					if (_feedbackMessage != "") {
						_DataBase.updateTask(_filename, updateInteger, copyofParameterToBeUpdated, copyofOriginalDetail);
						_DataBase.updateTextFile(_filename);
						setTaskList();

					} else {
						_feedbackMessage = FEEDBACK_TASK_UPDATED_SUCCESSFULLY;
					}
				}
			}
			_Logic_LogFile.writeToLogFile(_feedbackMessage);
		} else if ((parameterToBeUpdated == "start-time") || (parameterToBeUpdated == "end-time") || (parameterToBeUpdated == "deadline-time")) {

			if (detailToBeUpdated == "") {
				_feedbackMessage = ERROR_NO_CONTENT;
			} else {

				_feedbackMessage = checkTimeValidity(detailToBeUpdated);

				if (_feedbackMessage == "Pass Time Test") {

					string copyofParameterToBeUpdated = parameterToBeUpdated;
					string copyofOriginalDetail;

					if (copyofParameterToBeUpdated == "start-date") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskStartDate();
					} else if (copyofParameterToBeUpdated == "start-time") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskStartTime();
					} else if (copyofParameterToBeUpdated == "end-date") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskEndDate();
					} else if (copyofParameterToBeUpdated == "end-time") {
						copyofOriginalDetail = _storageTaskListCopy[updateInteger - 1].getTaskEndTime();
					}

					_DataBase.updateTask(_filename, updateInteger, parameterToBeUpdated, detailToBeUpdated);
					_DataBase.updateTextFile(_filename);
					setTaskList();

					_feedbackMessage = compareTaskDateandTime(_storageTaskListCopy[updateInteger - 1]);
					if (_feedbackMessage != "") {
						_DataBase.updateTask(_filename, updateInteger, copyofParameterToBeUpdated, copyofOriginalDetail);
						_DataBase.updateTextFile(_filename);
						setTaskList();

					} else {
						_feedbackMessage = FEEDBACK_TASK_UPDATED_SUCCESSFULLY;
					}
				}
			}
		} else if (parameterToBeUpdated == "priority") {
			if (detailToBeUpdated == "") {
				_feedbackMessage = ERROR_NO_CONTENT;
			} else {
				_DataBase.updateTask(_filename, updateInteger, parameterToBeUpdated, detailToBeUpdated);
				_DataBase.updateTextFile(_filename);
				setTaskList();
				_feedbackMessage = _DataBase.returnLogicFeedbackMessage();
			}
		}

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "delete") {
		int deleteInteger = Input.getDeleteInteger();

		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else if (deleteInteger > _storageTaskListCopy.size() || deleteInteger <= 0) {
			_feedbackMessage = ERROR_TASK_DELETED_UNSUCCESSFULLY;

		} else {
			_DataBase.deleteTask(_filename, deleteInteger);
			_DataBase.updateTextFile(_filename);
			setTaskList();
			_feedbackMessage = FEEDBACK_TASK_DELETED_SUCCESSFULLY;
		}

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "save") {

		string userDirectory = Input.getuserdir();

		changeFileDirectory(userDirectory);
		updatefileLocation(userDirectory);
		writeFileLocation(_fileLocation);
		_feedbackMessage = userDirectory;
		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "mark") {

		int markIndex = Input.getmarkindex();

		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else if (markIndex > _storageTaskListCopy.size() || markIndex <= 0) {
			_feedbackMessage = ERROR_TASK_MARKED_UNSUCCESSFULLY;
		} else {
			_DataBase.markTask(_filename, markIndex);
			_DataBase.updateTextFile(_filename);
			setTaskList();
			_feedbackMessage = FEEDBACK_TASK_MARKED_SUCCESSFULLY;
		}

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "unmark") {

		int unmarkIndex = Input.getmarkindex();

		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else if (unmarkIndex > _storageTaskListCopy.size() || unmarkIndex <= 0) {
			_feedbackMessage = ERROR_TASK_UNMARKED_UNSUCCESSFULLY;
		} else {
			_DataBase.unmarkTask(_filename, unmarkIndex);
			_DataBase.updateTextFile(_filename);
			setTaskList();
			_feedbackMessage = FEEDBACK_TASK_UNMARKED_SUCCESSFULLY;
		}

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "clear") {
		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else {
			_DataBase.clearAllTasks();
			setTaskList();
			_DataBase.updateTextFile(_filename);
			_feedbackMessage = FEEDBACK_CLEAR_ALL_TASKS;
		}

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "undo") {
		_DataBase.undoAction();
		_DataBase.updateTextFile(_filename);
		setTaskList();
		_feedbackMessage = _DataBase.returnLogicFeedbackMessage();

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	} else if (command == "sort") {
		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else {
			_DataBase.sortTaskByName(_filename);
			_DataBase.updateTextFile(_filename);
			setTaskList();
			_feedbackMessage = _DataBase.returnLogicFeedbackMessage();

			_Logic_LogFile.writeToLogFile(_feedbackMessage);

		}
	} else if (command == "view-c") {
		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else {
			_DataBase.viewCompletedTasks();
			vector<Task> tempTaskList = getCompletedTaskList();
			if (tempTaskList.empty()) {
				setTaskList();
			} else {
				setCompletedTaskList();
			}
			_feedbackMessage = _DataBase.returnLogicFeedbackMessage();

			_Logic_LogFile.writeToLogFile(_feedbackMessage);

		}
	} else if (command == "view-i") {
		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else {
			_DataBase.viewIncompleteTasks();
			setIncompleteTaskList();
			_feedbackMessage = _DataBase.returnLogicFeedbackMessage();

			_Logic_LogFile.writeToLogFile(_feedbackMessage);

		}
	} else if (command == "view") {

		setTaskList();
		if (_storageTaskListCopy.empty()) {
			_feedbackMessage = ERROR_EMPTY_LIST;
		} else {
			_feedbackMessage = FEEDBACK_VIEW_ALL_SUCCESSFULLY;

			_Logic_LogFile.writeToLogFile(_feedbackMessage);

		}
	} else {
		_feedbackMessage = ERROR_INVALID_USERINPUT;

		_Logic_LogFile.writeToLogFile(_feedbackMessage);

	}

	return _feedbackMessage;
}


	// End of segment: C:\Users\User\Desktop\TaskSotong\main\Logic\Logic.cpp





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\Logic\Logic.h
	 */

#ifndef LOGIC_H
#define LOGIC_H

//#define NDEBUG

#include "..\UI\UI.h"
#include "..\Parser\Parser.h"
#include "..\Storage\Storage.h"
#include "..\Common\Task.h"
#include "..\TaskSotong_Log\Log.h"

#include <iostream> 
#include <string> 
#include <sstream> 
#include <vector> 
#include <fstream>
#include <cctype>
#include <algorithm>
#include <assert.h>

using namespace std;

class Logic {

private:

	UI _UserInterface;
	Parser _ParserComponent;
	Storage _DataBase;

	vector<string> _fileLocation;
	vector<Task> _resultVector;
	vector<Task> _storageTaskListCopy;

	string _userInput;
	string _filename;
	string _feedbackMessage;

	static string SAVING_LOCATON_HISTORY;
	static string ERROR_INVALID_USERINPUT;
	static string ERROR_EXISTING_TASK;
	static string ERROR_TASK_UPDATED_UNSUCCESSFULLY;
	static string ERROR_TASK_DELETED_UNSUCCESSFULLY;
	static string ERROR_TASK_MARKED_UNSUCCESSFULLY;
	static string ERROR_TASK_UNMARKED_UNSUCCESSFULLY;
	static string ERROR_EMPTY_LIST;
	static string ERROR_TASK_INSUFFICIENT_PARAMETERS;
	static string ERROR_NO_INDEX;
	static string ERROR_INDEX_OUT_OF_RANGE;
	static string ERROR_NO_COMPONENT;
	static string ERROR_COMPONENT_INVALID;
	static string ERROR_NO_CONTENT;
	static string ERROR_INVALID_CONTENT;
	static string ERROR_INVALID_YEAR;
	static string ERROR_INVALID_MONTH;
	static string ERROR_INVALID_DAY;
	static string ERROR_INVALID_HOUR;
	static string ERROR_INVALID_MINUTE;
	static string ERROR_START_TIME_AFTER_END_TIME;
	static string ERROR_START_DATE_AFTER_END_DATE; 

	static string FEEDBACK_TASK_ADDED_SUCCESSFULLY;
	static string FEEDBACK_DISPLAY_ALL_TASKS;
	static string FEEDBACK_TASK_UPDATED_SUCCESSFULLY;
	static string FEEDBACK_TASK_DELETED_SUCCESSFULLY;
	static string FEEDBACK_SAVING_FILE_DIRECTORY_CHANGED;
	static string FEEDBACK_TASK_MARKED_SUCCESSFULLY;
	static string FEEDBACK_TASK_UNMARKED_SUCCESSFULLY;
	static string FEEDBACK_CLEAR_ALL_TASKS;
	static string FEEDBACK_UNDO_PREVIOUS_TASK;
	static string FEEDBACK_SEARCH_TASK_BY_KEYWORD;
	static string FEEDBACK_SORT_TASK_BY_KEYWORD;
	static string FEEDBACK_VIEW_ALL_SUCCESSFULLY;

	Log _Logic_LogFile;

public:

	string checkTimeValidity(string);

	string checkDateValidity(string);

	string checkTaskDatenTimeValidity(Task);

	string convertYearToCorrectForm(string);

	string convertTimeToCorrectForm(string);

	string compareTaskDateandTime(Task);

	void setTaskList();

	vector<Task> getTaskList();

	void setCompletedTaskList();

	vector<Task> getCompletedTaskList();

	void setIncompleteTaskList();

	vector<Task> getIncompleteTaskList();

	void initialiseSetUp();

	void initialiseFileLocationFile();

	void writeFileLocation(vector<string>);

	bool checkIfFileIsAtExeLocation();

	string getLastFileLocation();

	void updatefileLocation(string);

	string getExePath();

	void createNewDirectory(string);

	void changeFileDirectory(string);

	void setFileName(string);

	string getFileName();

	paraList* getParaList(string);

	string getLowerCaseCommand(paraList);

	Task getTask(paraList);

	vector<string> getTextFileCopy();

	void callInitialise(string);

	bool ExistingTask(Task);

	string getFeedbackMsg();

	string executeCommand(paraList);

};
#endif

	// End of segment: C:\Users\User\Desktop\TaskSotong\main\Logic\Logic.h





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\ParaList_Testing\unittest1.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ParaList_Testing {
	TEST_CLASS(ParaList_Testing) {
public:

	TEST_METHOD(getTask_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		Task actual = test.getTask();
		Task* testTask = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		Task expected = *testTask;

		string actual1 = actual.getTaskDetails();
		string expected1 = expected.getTaskDetails();

		Assert::AreEqual(actual1, expected1);
	}

	TEST_METHOD(getCommand_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);


		string actual = test.getCommand();
		string expected = "add";

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(getDeleteInteger_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);


		int actual = test.getDeleteInteger();
		int expected = 1;

		Assert::AreEqual(actual, expected);

		//This is a boundary testing for getDeleteInteger. 
		//when the user key in delete 0, it is an invalid index, just outside the boundary
		paraList test1;
		Task* taskTest1 = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test1.setparaList("add", 0, 2, 3, "KEYWORD", "INPUT", *taskTest);

		int actual1 = test.getDeleteInteger();
		int expected1 = 0;

		Assert::AreEqual(actual, expected);

	}

	TEST_METHOD(getDisplayInteger_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);


		int actual = test.getDisplayInteger();
		int expected = 2;

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(getUpdateInteger_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);


		int actual = test.getUpdateInteger();
		int expected = 3;

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(processCommand_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.processCommand("delete");
		string actual = test.getCommand();
		string expected = "delete";

		Assert::AreEqual(actual, expected);
	}

	//void processTask(string inputTask);

	TEST_METHOD(processDeleteNumber_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.processDeleteNumber(2);
		int actual = test.getDeleteInteger();
		int expected = 2;

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(processDisplayNumber_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.processDisplayNumber(3);
		int actual = test.getDisplayInteger();
		int expected = 3;

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(processUpdateNumber_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.processUpdateNumber(1);
		int actual = test.getUpdateInteger();
		int expected = 1;

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(clearAllNumber_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.clearAllNumber();

		int actual = test.getDeleteInteger();
		int expected = NULL;

		int actual1 = test.getDisplayInteger();
		int expected1 = NULL;

		int actual2 = test.getUpdateInteger();
		int expected2 = NULL;

		Assert::AreEqual(actual, expected);
		Assert::AreEqual(actual1, expected1);
		Assert::AreEqual(actual2, expected2);
	}

	TEST_METHOD(getKeyword_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);


		string actual = test.getKeyword();
		string expected = "KEYWORD";

		Assert::AreEqual(actual, expected);
	}


	TEST_METHOD(getInput_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);


		string actual = test.getInput();
		string expected = "INPUT";

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(processKeyWord_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.processKeyWord("KEYWORD!");
		string actual = test.getKeyword();
		string expected = "KEYWORD!";

		Assert::AreEqual(actual, expected);
	}

	TEST_METHOD(processInput_test) {
		paraList test;
		Task* taskTest = new Task("Name", "StartDate", "StartTime", "EndDate", "EndTime", "DeadlineDate", "DeadlineTime", "Priority", "Incompleted");
		test.setparaList("add", 1, 2, 3, "KEYWORD", "INPUT", *taskTest);

		test.processInput("INPUT!");
		string actual = test.getInput();
		string expected = "INPUT!";

		Assert::AreEqual(actual, expected);
	}


	};
}

/*
paraList();
//for unit testing purpose.

void clearTask();

*/
	// End of segment: C:\Users\User\Desktop\TaskSotong\main\ParaList_Testing\unittest1.cpp





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\tasksotongUI\tasksotongGUI.cpp
	 */

#include "tasksotongGUI.h"

using namespace System;
using namespace System::Windows::Forms;

[STAThread]
int main(array<String^>^ args) {
	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false);

	tasksotongUI::tasksotongGUI mainWindow;
	Application::Run(%mainWindow);
	
}

	// End of segment: C:\Users\User\Desktop\TaskSotong\main\tasksotongUI\tasksotongGUI.cpp





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\tasksotongUI\tasksotongGUI.h
	 */

#pragma once

#include "..\Logic\Logic.h"
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <msclr\marshal_cppstd.h>


namespace tasksotongUI {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	/// <summary>
	/// Summary for tasksotongGUI
	/// </summary>



	//hashtable added
	// Hash map class template
	/*template <typename K, typename V, typename F = KeyHash<K>>
	class HashMap {
	public:
	HashMap() {
	// construct zero initialized hash table of size
	table = new HashNode<K, V> *[TABLE_SIZE]();
	}

	~HashMap() {
	// destroy all buckets one by one
	for (int i = 0; i < TABLE_SIZE; ++i) {
	HashNode<K, V> *entry = table[i];
	while (entry != NULL) {
	HashNode<K, V> *prev = entry;
	entry = entry->getNext();
	delete prev;
	}
	table[i] = NULL;
	}
	// destroy the hash table
	delete[] table;
	}

	bool get(const K &key, V &value) {
	unsigned long hashValue = hashFunc(key);
	HashNode<K, V> *entry = table[hashValue];

	while (entry != NULL) {
	if (entry->getKey() == key) {
	value = entry->getValue();
	return true;
	}
	entry = entry->getNext();
	}
	return false;
	}

	void put(const K &key, const V &value) {
	unsigned long hashValue = hashFunc(key);
	HashNode<K, V> *prev = NULL;
	HashNode<K, V> *entry = table[hashValue];

	while (entry != NULL && entry->getKey() != key) {
	prev = entry;
	entry = entry->getNext();
	}

	if (entry == NULL) {
	entry = new HashNode<K, V>(key, value);
	if (prev == NULL) {
	// insert as first bucket
	table[hashValue] = entry;
	} else {
	prev->setNext(entry);
	}
	} else {
	// just update the value
	entry->setValue(value);
	}
	}

	void remove(const K &key) {
	unsigned long hashValue = hashFunc(key);
	HashNode<K, V> *prev = NULL;
	HashNode<K, V> *entry = table[hashValue];

	while (entry != NULL && entry->getKey() != key) {
	prev = entry;
	entry = entry->getNext();
	}

	if (entry == NULL) {
	// key not found
	return;
	} else {
	if (prev == NULL) {
	// remove first bucket of the list
	table[hashValue] = entry->getNext();
	} else {
	prev->setNext(entry->getNext());
	}
	delete entry;
	}
	}

	private:
	// hash table
	HashNode<K, V> **table;
	F hashFunc;
	};





	private enum Accelerators {
	Unspecified = 0, Home, Save, Print, Logout
	};

	HashMap _accelHash() = new HashMap();
	public class AcceleratorKey {
	private Keys key_ = Keys.None;
	public AcceleratorKey() {
	}

	public AcceleratorKey(Keys key) {
	key_ = key;
	}

	public Keys Key
	{
	get{ return key_; }
	set{ key_ = value; }
	}

	public override Int32 GetHashCode() {
	return (Int32)key_;
	}

	public override bool Equals(Object obj) {
	// It is unlikely that two hashcodes would
	// be equal... :)
	if (obj.GetHashCode() == (Int32)key_) return true;

	return false;
	}
	}

	_accelHash.Add(new AcceleratorKey(Keys.Alt | Keys.H),
	Accelerators.Home);
	_accelHash.Add(new AcceleratorKey(Keys.Alt | Keys.S),
	Accelerators.Save);
	_accelHash.Add(new AcceleratorKey(Keys.Alt | Keys.P),
	Accelerators.Print);
	_accelHash.Add(new AcceleratorKey(Keys.Alt | Keys.X),
	Accelerators.Logout);

	protected override bool ProcessCmdKey(ref Message msg,
	Keys keyData) {
	// Check this key...
	bool bHandled = false;

	// Look up value
	Accelerators accel = Accelerators.Unspecified;
	if (_accelHash.ContainsKey(AcceleratorKey(keyData))) {
	accel = (Accelerators)_accelHash[key];

	switch (accel) {
	case Accelerators.Home:
	DisplayHome();
	bHandled = true;
	break;

	case Accelerators.Save:
	Save();
	bHandled = true;
	break;

	case Accelerators.Print:
	Print();
	bHandled = true;
	break;

	case Accelerators.Logout:
	LogOut();
	bHandled = true;
	break;

	case Accelerators.Unspecified:
	default:
	break;

	} // switch
	} // if

	return bHandled;
	}
	*/

	//HashTable ended

	public ref class tasksotongGUI : public System::Windows::Forms::Form {
	public:
		tasksotongGUI(void) {
			TSLogic = new Logic;
			InitializeComponent();
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~tasksotongGUI() {
			if (components) {
				delete components;

			}
		}
	private: System::Windows::Forms::TextBox^  UserInputBox;
	private: System::Windows::Forms::Button^  Enter;
	protected:



	private: System::Windows::Forms::TextBox^  WelcomeBox;


	private: System::Windows::Forms::Button^  IncompleteButton;
	private: System::Windows::Forms::Button^  PriorityButton;
	private: System::Windows::Forms::Button^  DeadlineButton;



	private:
		/// <summary>
		/// Required designer variable.
		Logic* TSLogic;


	private: System::Windows::Forms::Button^  CompleteButton;












	private: System::Windows::Forms::RichTextBox^  Display_richTextBox;
	private: System::Windows::Forms::Button^  button1;
	private: System::Windows::Forms::TextBox^  textBox1;

			 /// </summary>
			 System::ComponentModel::Container ^components;

#pragma region Windows Form Designer generated code
			 /// <summary>
			 /// Required method for Designer support - do not modify
			 /// the contents of this method with the code editor.
			 /// </summary>
			 void InitializeComponent(void) {
				 System::ComponentModel::ComponentResourceManager^  resources = (gcnew System::ComponentModel::ComponentResourceManager(tasksotongGUI::typeid));
				 this->UserInputBox = (gcnew System::Windows::Forms::TextBox());
				 this->WelcomeBox = (gcnew System::Windows::Forms::TextBox());
				 this->IncompleteButton = (gcnew System::Windows::Forms::Button());
				 this->PriorityButton = (gcnew System::Windows::Forms::Button());
				 this->DeadlineButton = (gcnew System::Windows::Forms::Button());
				 this->Enter = (gcnew System::Windows::Forms::Button());
				 this->CompleteButton = (gcnew System::Windows::Forms::Button());
				 this->Display_richTextBox = (gcnew System::Windows::Forms::RichTextBox());
				 this->button1 = (gcnew System::Windows::Forms::Button());
				 this->textBox1 = (gcnew System::Windows::Forms::TextBox());
				 this->SuspendLayout();
				 // 
				 // UserInputBox
				 // 
				 this->UserInputBox->BackColor = System::Drawing::Color::DimGray;
				 resources->ApplyResources(this->UserInputBox, L"UserInputBox");
				 this->UserInputBox->ForeColor = System::Drawing::Color::MintCream;
				 this->UserInputBox->Name = L"UserInputBox";
				 this->UserInputBox->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &tasksotongGUI::UserInputBox_KeyPress);
				 // 
				 // WelcomeBox
				 // 
				 this->WelcomeBox->BackColor = System::Drawing::Color::MistyRose;
				 resources->ApplyResources(this->WelcomeBox, L"WelcomeBox");
				 this->WelcomeBox->ForeColor = System::Drawing::Color::Goldenrod;
				 this->WelcomeBox->Name = L"WelcomeBox";
				 this->WelcomeBox->Click += gcnew System::EventHandler(this, &tasksotongGUI::WelcomeBox_TextChanged);
				 this->WelcomeBox->TextChanged += gcnew System::EventHandler(this, &tasksotongGUI::WelcomeBox_TextChanged);
				 // 
				 // IncompleteButton
				 // 
				 this->IncompleteButton->BackColor = System::Drawing::Color::LightCoral;
				 resources->ApplyResources(this->IncompleteButton, L"IncompleteButton");
				 this->IncompleteButton->ForeColor = System::Drawing::SystemColors::Control;
				 this->IncompleteButton->Name = L"IncompleteButton";
				 this->IncompleteButton->UseVisualStyleBackColor = false;
				 this->IncompleteButton->Click += gcnew System::EventHandler(this, &tasksotongGUI::IncompleteButton_Click);
				 // 
				 // PriorityButton
				 // 
				 this->PriorityButton->BackColor = System::Drawing::Color::PaleVioletRed;
				 resources->ApplyResources(this->PriorityButton, L"PriorityButton");
				 this->PriorityButton->ForeColor = System::Drawing::SystemColors::Control;
				 this->PriorityButton->Name = L"PriorityButton";
				 this->PriorityButton->UseVisualStyleBackColor = false;
				 this->PriorityButton->Click += gcnew System::EventHandler(this, &tasksotongGUI::PriorityButton_Click);
				 // 
				 // DeadlineButton
				 // 
				 this->DeadlineButton->BackColor = System::Drawing::Color::DarkSlateBlue;
				 resources->ApplyResources(this->DeadlineButton, L"DeadlineButton");
				 this->DeadlineButton->ForeColor = System::Drawing::SystemColors::Control;
				 this->DeadlineButton->Name = L"DeadlineButton";
				 this->DeadlineButton->UseVisualStyleBackColor = false;
				 this->DeadlineButton->Click += gcnew System::EventHandler(this, &tasksotongGUI::DeadlineButton_Click);
				 // 
				 // Enter
				 // 
				 this->Enter->BackColor = System::Drawing::Color::MidnightBlue;
				 resources->ApplyResources(this->Enter, L"Enter");
				 this->Enter->ForeColor = System::Drawing::SystemColors::Control;
				 this->Enter->Name = L"Enter";
				 this->Enter->UseVisualStyleBackColor = false;
				 this->Enter->Click += gcnew System::EventHandler(this, &tasksotongGUI::Enter_Click);
				 // 
				 // CompleteButton
				 // 
				 this->CompleteButton->BackColor = System::Drawing::Color::LightPink;
				 resources->ApplyResources(this->CompleteButton, L"CompleteButton");
				 this->CompleteButton->ForeColor = System::Drawing::SystemColors::Control;
				 this->CompleteButton->Name = L"CompleteButton";
				 this->CompleteButton->UseVisualStyleBackColor = false;
				 this->CompleteButton->Click += gcnew System::EventHandler(this, &tasksotongGUI::Complete_click);
				 // 
				 // Display_richTextBox
				 // 
				 this->Display_richTextBox->BackColor = System::Drawing::Color::RosyBrown;
				 resources->ApplyResources(this->Display_richTextBox, L"Display_richTextBox");
				 this->Display_richTextBox->ForeColor = System::Drawing::Color::MintCream;
				 this->Display_richTextBox->Name = L"Display_richTextBox";
				 this->Display_richTextBox->ReadOnly = true;
				 this->Display_richTextBox->TextChanged += gcnew System::EventHandler(this, &tasksotongGUI::Display_richTextBox_TextChanged);
				 // 
				 // button1
				 // 
				 this->button1->BackColor = System::Drawing::Color::SaddleBrown;
				 this->button1->ForeColor = System::Drawing::SystemColors::ButtonHighlight;
				 resources->ApplyResources(this->button1, L"button1");
				 this->button1->Name = L"button1";
				 this->button1->UseVisualStyleBackColor = false;
				 this->button1->Click += gcnew System::EventHandler(this, &tasksotongGUI::button1_Click);
				 // 
				 // textBox1
				 // 
				 this->textBox1->BackColor = System::Drawing::SystemColors::ScrollBar;
				 resources->ApplyResources(this->textBox1, L"textBox1");
				 this->textBox1->Name = L"textBox1";
				 // 
				 // tasksotongGUI
				 // 
				 resources->ApplyResources(this, L"$this");
				 this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
				 this->BackColor = System::Drawing::Color::BurlyWood;
				 this->Controls->Add(this->textBox1);
				 this->Controls->Add(this->button1);
				 this->Controls->Add(this->Enter);
				 this->Controls->Add(this->DeadlineButton);
				 this->Controls->Add(this->PriorityButton);
				 this->Controls->Add(this->IncompleteButton);
				 this->Controls->Add(this->CompleteButton);
				 this->Controls->Add(this->WelcomeBox);
				 this->Controls->Add(this->UserInputBox);
				 this->Controls->Add(this->Display_richTextBox);
				 this->FormBorderStyle = System::Windows::Forms::FormBorderStyle::FixedSingle;
				 this->MaximizeBox = false;
				 this->Name = L"tasksotongGUI";
				 this->Load += gcnew System::EventHandler(this, &tasksotongGUI::tasksotongGUI_Load);
				 this->ResumeLayout(false);
				 this->PerformLayout();

			 }


#pragma endregion


	private: System::Void UserInputBox_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) {
		//DisplayTaskBox->Text = "debugging1: " + UserInputBox->Text + "testing1";
		if (e->KeyChar == (char)13) {

			string tempUserInput = msclr::interop::marshal_as<std::string>(UserInputBox->Text);

			int i = tempUserInput.find_first_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSUVWXYZ");
			string userInput = tempUserInput.substr(i);

			//DisplayTaskBox->Text ="debugging2: "+ UserInputBox->Text + "testing2";

			paraList* storageInput = TSLogic->getParaList(userInput);

			std::string feedbackmsg = TSLogic->executeCommand(*storageInput);
			//DisplayTaskBox->Clear();
			vector<Task> taskListCopy_fromLogic = TSLogic->getTaskList();

			//String^ stringnewlala = gcnew String(userInput.c_str());
			//DisplayTaskBox->Text = stringnewlala + "\r\n" + textFileCopy_fromLogic.size().ToString();

			//DisplayTaskBox->Text = textFileCopy_fromLogic.size().ToString();

			Display_richTextBox->Clear();

			for (int i = 0; i < taskListCopy_fromLogic.size(); i++) {

				string tempName = "\t" + to_string(i + 1) + ".\t" + taskListCopy_fromLogic[i].getTaskName() + "\r\n";
				String^ displayName = gcnew String(tempName.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Segoe UI", 15.75, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = displayName;

				string start = "START: \t";
				String^ startLine = gcnew String(start.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 8, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = startLine;

				string tempStartDate;
				string tempStartTime;
				if (taskListCopy_fromLogic[i].getTaskStartDate() == "") {
					tempStartDate = "\t-";
				} else {
					tempStartDate = taskListCopy_fromLogic[i].getTaskStartDate();
				}
				if (taskListCopy_fromLogic[i].getTaskStartTime() == "") {
					tempStartTime = "-";
				} else {
					tempStartTime = taskListCopy_fromLogic[i].getTaskStartTime();
				}
				string tempStartDnT = tempStartDate + "\t" + tempStartTime + "\r\n";
				String^ displayStartDnT = gcnew String(tempStartDnT.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 10, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkBlue;
				Display_richTextBox->SelectedText = displayStartDnT;

				string end = "END: \t\t";
				String^ endLine = gcnew String(end.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 8, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = endLine;

				string tempEndDate;
				string tempEndTime;
				if (taskListCopy_fromLogic[i].getTaskEndDate() == "") {
					tempEndDate = "\t-";
				} else {
					tempEndDate = taskListCopy_fromLogic[i].getTaskEndDate();
				}
				if (taskListCopy_fromLogic[i].getTaskEndTime() == "") {
					tempEndTime = "-";
				} else {
					tempEndTime = taskListCopy_fromLogic[i].getTaskEndTime();
				}
				string tempEndDnT = tempEndDate + "\t" + tempEndTime + "\r\n";
				String^ displayEndDnT = gcnew String(tempEndDnT.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 10, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkBlue;
				Display_richTextBox->SelectedText = displayEndDnT;

				string deadLine = "DEADLINE: \t";
				String^ deadLineLine = gcnew String(deadLine.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 8, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = deadLineLine;

				string tempDeadlineDate;
				string tempDeadlineTime;
				if (taskListCopy_fromLogic[i].getTaskDeadlineDate() == "") {
					tempDeadlineDate = "\t-";
				} else {
					tempDeadlineDate = taskListCopy_fromLogic[i].getTaskDeadlineDate();
				}
				if (taskListCopy_fromLogic[i].getTaskDeadlineTime() == "") {
					tempDeadlineTime = "-";
				} else {
					tempDeadlineTime = taskListCopy_fromLogic[i].getTaskDeadlineTime();
				}
				string tempDeadlineDnT = tempDeadlineDate + "\t" + tempDeadlineTime + "\r\n";
				String^ displayDeadlineDnT = gcnew String(tempDeadlineDnT.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 10, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkBlue;
				Display_richTextBox->SelectedText = displayDeadlineDnT;


				string tempP;
				if (taskListCopy_fromLogic[i].getTaskPriority() == "") {
					tempP = "-";
				} else {
					tempP = taskListCopy_fromLogic[i].getTaskPriority();
				}
				string tempPriority = "\t\t" + tempP + "\t";
				String^ priority = gcnew String(tempPriority.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 12, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkSlateGray;
				Display_richTextBox->SelectedText = priority;


				string tempS;
				if (taskListCopy_fromLogic[i].getTaskStatus() == "") {
					tempS = "\t-";
				} else {
					tempS = taskListCopy_fromLogic[i].getTaskStatus();
				}
				string tempStatus = tempS + "\r\n";
				String^ status = gcnew String(tempStatus.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 12, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkMagenta;
				Display_richTextBox->SelectedText = status;
			}


			String^ feedback = gcnew String(feedbackmsg.c_str());
			WelcomeBox->Text = feedback;

			UserInputBox->Clear();
		}

	}

	private: System::Void Enter_Click(System::Object^  sender, System::EventArgs^  e) {

	}


	private: System::Void Complete_click(System::Object^  sender, System::EventArgs^  e) {
		MessageBox::Show("hello world!");
	}

	private: System::Void DisplayTaskBox_TextChanged(System::Object^  sender, System::EventArgs^  e) {


	}
	private: System::Void IncompleteButton_Click(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void PriorityButton_Click(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void DeadlineButton_Click(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void WelcomeBox_TextChanged(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void tasksotongGUI_Load(System::Object^  sender, System::EventArgs^  e) {

		TSLogic->initialiseSetUp();
		TSLogic->setTaskList();	
		
		vector<Task> taskListCopy_fromLogic = TSLogic->getTaskList();

		
		if (taskListCopy_fromLogic.size() == 0) {
			

		} else {
			Display_richTextBox->Clear();
			for (int i = 0; i < taskListCopy_fromLogic.size(); i++) {

				string tempName = "\t" + to_string(i + 1) + ".\t" + taskListCopy_fromLogic[i].getTaskName() + "\r\n";
				String^ displayName = gcnew String(tempName.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Segoe UI", 15.75, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = displayName;

				string start = "START: \t";
				String^ startLine = gcnew String(start.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 8, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = startLine;
				
				string tempStartDate;
				string tempStartTime;
				if (taskListCopy_fromLogic[i].getTaskStartDate() == "") {
					tempStartDate = "\t-";
				} else {
					tempStartDate = taskListCopy_fromLogic[i].getTaskStartDate();
				}
				if (taskListCopy_fromLogic[i].getTaskStartTime() == "") {
					tempStartTime = "-";
				} else {
					tempStartTime = taskListCopy_fromLogic[i].getTaskStartTime();
				}
				string tempStartDnT =tempStartDate + "\t" + tempStartTime + "\r\n";
				String^ displayStartDnT = gcnew String(tempStartDnT.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 10, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkBlue;
				Display_richTextBox->SelectedText = displayStartDnT;

				string end = "END: \t\t";
				String^ endLine = gcnew String(end.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 8, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = endLine;

				string tempEndDate;
				string tempEndTime;
				if (taskListCopy_fromLogic[i].getTaskEndDate() == "") {
					tempEndDate = "\t-";
				} else {
					tempEndDate = taskListCopy_fromLogic[i].getTaskEndDate();
				}
				if (taskListCopy_fromLogic[i].getTaskEndTime() == "") {
					tempEndTime = "-";
				} else {
					tempEndTime = taskListCopy_fromLogic[i].getTaskEndTime();
				}
				string tempEndDnT = tempEndDate + "\t" + tempEndTime + "\r\n";
				String^ displayEndDnT = gcnew String(tempEndDnT.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 10, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkBlue;
				Display_richTextBox->SelectedText = displayEndDnT;

				string deadLine = "DEADLINE: \t";
				String^ deadLineLine = gcnew String(deadLine.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 8, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::Snow;
				Display_richTextBox->SelectedText = deadLineLine;

				string tempDeadlineDate;
				string tempDeadlineTime;
				if (taskListCopy_fromLogic[i].getTaskDeadlineDate() == "") {
					tempDeadlineDate = "\t-";
				} else {
					tempDeadlineDate = taskListCopy_fromLogic[i].getTaskDeadlineDate();
				}
				if (taskListCopy_fromLogic[i].getTaskDeadlineTime() == "") {
					tempDeadlineTime = "-";
				} else {
					tempDeadlineTime = taskListCopy_fromLogic[i].getTaskDeadlineTime();
				}
				string tempDeadlineDnT = tempDeadlineDate + "\t" + tempDeadlineTime + "\r\n";
				String^ displayDeadlineDnT = gcnew String(tempDeadlineDnT.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 10, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkBlue;
				Display_richTextBox->SelectedText = displayDeadlineDnT;


				string tempP;
				if (taskListCopy_fromLogic[i].getTaskPriority() == "") {
					tempP = "-";
				} else {
					tempP = taskListCopy_fromLogic[i].getTaskPriority();
				}
				string tempPriority = "\t\t" + tempP + "\t";
				String^ priority = gcnew String(tempPriority.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 12, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkSlateGray;
				Display_richTextBox->SelectedText = priority;


				string tempS;
				if (taskListCopy_fromLogic[i].getTaskStatus() == "") {
					tempS = "\t-";
				} else {
					tempS = taskListCopy_fromLogic[i].getTaskStatus();
				}
				string tempStatus = tempS + "\r\n";
				String^ status = gcnew String(tempStatus.c_str());
				Display_richTextBox->SelectionFont = gcnew System::Drawing::Font("Seoge UI", 12, FontStyle::Bold);
				Display_richTextBox->SelectionColor = Color::DarkMagenta;
				Display_richTextBox->SelectedText = status;
			}
		}


	}


	private: System::Void featuresToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void Display_richTextBox_TextChanged(System::Object^  sender, System::EventArgs^  e) {
	}
	// End of segment: C:\Users\User\Desktop\TaskSotong\main\tasksotongUI\tasksotongGUI.h





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\TaskSotong_Log\Log.cpp
	 */


#include "Log.h"

void Log::writeToLogFile(string stringToBeLogged) {

	ofstream writeFile("log.txt", ios::app);
	writeFile << stringToBeLogged<< endl;

	writeFile.close();
}

void Log::clearLogFile() {


	ofstream writeFile("log.txt");
	writeFile.close();
}
	// End of segment: C:\Users\User\Desktop\TaskSotong\main\TaskSotong_Log\Log.cpp





	/**
	 * origin: C:\Users\User\Desktop\TaskSotong\main\TaskSotong_Log\Log.h
	 */


#ifndef LOG_H
#define LOG_H

#include<iostream>
#include<vector>
#include<string>
#include<fstream>

using namespace std;

class Log {
private:

public:
	void writeToLogFile(string);
	void clearLogFile();
};
#endif
	// End of segment: C:\Users\User\Desktop\TaskSotong\main\TaskSotong_Log\Log.h





